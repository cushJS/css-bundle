// Generated by CoffeeScript 2.3.0
var Bundle, CSSBundle, ErrorTracer, MagicString, isObject, sorcery, uhoh;

({ErrorTracer, uhoh} = require('cush/utils'));

MagicString = require('@cush/magic-string');

isObject = require('is-object');

sorcery = require('@cush/sorcery');

Bundle = require('cush/lib/Bundle');

CSSBundle = (function() {
  class CSSBundle extends Bundle {
    _wrapSourceMapURL(url) {
      return `/*# sourceMappingURL=${url} */`;
    }

    async _concat() {
      var addAsset, assets, bundle, chain, err, event, files, hook, i, len, ref, result;
      bundle = new MagicString.Bundle;
      files = {}; // asset lookup by filename
      assets = []; // sparse asset map for deduping
      addAsset = (asset) => {
        var code, filename, ref;
        if (assets[asset.id]) {
          return;
        }
        assets[asset.id] = asset;
        if (asset.ext !== '.css') {
          uhoh('Unsupported asset type: ' + asset.path(), 'BAD_ASSET');
        }
        filename = this.relative(asset.path());
        files[filename] = asset;
        code = new MagicString(asset.content);
        if (this.dev) {
          code.prepend(`\n/* ${filename} */\n`);
        }
        code.trimEnd();
        // strip any `@import` statements
        if ((ref = asset.deps) != null) {
          ref.forEach(function(dep) {
            code.remove(dep.start, dep.end);
            return addAsset(dep.asset);
          });
        }
        return bundle.addSource({
          filename,
          content: code
        });
      };
      addAsset(this.main);
      chain = [
        {
          content: bundle.toString(),
          map: bundle.generateMap({
            includeContent: false
          })
        }
      ];
      if (event = this._events.bundle) {
        try {
          ref = event.hooks;
          for (i = 0, len = ref.length; i < len; i++) {
            hook = ref[i];
            result = (await hook(chain[0].content, this));
            if (isObject(result != null ? result.map : void 0)) {
              chain.unshift(result);
            }
          }
        } catch (error) {
          err = error;
          if (err.line != null) {
            (() => {
              var opts;
              opts = {
                readFile: function(filename) {
                  return files[filename].content;
                }
              };
              ErrorTracer(chain, opts)(err);
              return err.snippet = snipSyntaxError(chain[0].content, err);
            })();
          }
          throw err;
        }
      }
      return {
        content: chain[0].content,
        map: sorcery(chain, {
          getMap: function(filename) {
            return files[filename].map || false;
          },
          includeContent: false
        })
      };
    }

  };

  CSSBundle.id = 'css';

  CSSBundle.exts = ['.css'];

  CSSBundle.plugins = ['postcss'];

  return CSSBundle;

}).call(this);

module.exports = CSSBundle;
